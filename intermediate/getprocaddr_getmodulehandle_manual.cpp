#include "PEstructs.h"
#include "helpers.h"
#include <stdio.h>

typedef HMODULE (WINAPI * LoadLibrary_t)(LPCSTR lpFileName);
LoadLibrary_t pLoadLibraryA = NULL;

// LPCWSTR -> constant pointer to a Unicode String (wide)
HMODULE WINAPI hlpGetModuleHandle(LPCWSTR sModuleName){
	
	// get the offset of Proces Environment Block
#ifdef _M_IX86
	// la función __readfsdword() se utiliza para leer el valor de un registro especial llamado FS (Selector de Segmento de Función), que apunta a una estructura de datos que contiene información sobre el proceso actual. El valor hexadecimal 0x30 es el desplazamiento (offset) desde la base de la estructura del Thread Information Block (TIB) al campo que contiene el puntero al PEB.
	PEB * ProcEnvBlk = (PEB *) __readfsdword(0x30);
#else
	PEB * ProcEnvBlk = (PEB *) __readgsdword(0x60);
#endif

	// return base address of a calling module
	if (sModuleName == NULL)
		return (HMODULE) (ProcEnvBlk->ImageBaseAddress); // saca la dirección del proceso si no se le pasa el nombre de un módulo
	
	PEB_LDR_DATA * Ldr = ProcEnvBlk->Ldr; // ldr contains information about the loaded process
	LIST_ENTRY * pStartListEntry = ModuleList->Flink;
	// itera sobre un LIST_ENTRY y mira si encuentra el módulo
	for(LIST_ENTRY * pListEntry = pStartListEntry;
					 pListEntry != ModuleList;
					 pListEntry = pListEntry->Flink){
						 
	// get current Data Table Entry
	LDR_DATA_TABLE_ENTRY *pEntry = (LDR_DATA_TABLE_ENTRY *) ((BYTE *) pListEntry - sizeof(LIST_ENTRY));
	
	// check if module is found and return its base address
	if (lstrcmpiW(pEntry->BaseDllName.Buffer, sModuleName) == 0)
		return (HMODULE) pEntry->DllBase;
						 
	}
	
	//otherwise
	return NULL;
}
7
FARPROC WINAPI hlpGetProcAddress(HMODULE hMod, char * sProcName){
	
	// 1- get the base address of the executable
	// 2- parse the PE header and get to the export data dir address
	// 3- get the eat, function name tables and hints tables from the export data dir addr 
	
	char * pBaseAddr = (char *) hMod;
	// PE HAS CERTAIN HEADERS WHICH MAY CONTAIN INFO INTERESTING TO US
	// get pointers to main headers / structures 
	IMAGE_DOS_HEADER *pDosHdr = (IMAGE_DOS_HEADER *) pBaseAddr;
	IMAGE_NT_HEADERS * pNTHdr = (IMAGE_NT_HEADERS * ) (pBaseAddr + pDosHdr->e_lfanew);
	IMAGE_OPTIONAL_HEADER * pOptionalHdr = &pNTHdr->OptionalHeader;
	IMAGE_DATA_DIRECTORY *pExportDataDir = (IMAGE_DATA_DIRECTORY *) (&pOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]);
	IMAGE_EXPORT_DIRECTORY *pExportDirAddr = (IMAGE_EXPORT_DIRECTORY *) (pBaseAddr + pExportDataDir->VirtualAddress);
	
	// resolve addresses to Export Address Table, table of funciton names and "table of ordinals"
	DWORD * pEAT = (DWORD *) (pBaseAddr + pExportDataDir->AddressOfFunctions);
	DWORD * pFuncNameTbl = (DWORD *) (pBaseAddr + pExportDataDir->AddressOfNames);
	WORD * pHintsTbl = (DWORD *) (pBaseAddr + pExportDataDir->AddressOfNameOrdinals);
	
	// function address we're looking for
	void * pProcAddr = NULL;
	
	// resolve function by ordinal 
	if( (DWORD_PTR) sProcName >> 16 == 0) {
		
		WORD ordinal = (WORD) sProcName & 0xFFFF; // convert to WORD 
		DWORD Base = pExportDataDir->Base; // first ordinal number
		
		
		if (ordinal < Base || ordinal >= Base + pExportDataDir->NumberOfFunctions)
			return NULL;
		
		// get the function virtual address = RVA + BaseAddr
		
		pProcAddr = (FARPROC) (pBaseAddr + (DWORD_PTR) pEAT[ordinal - Base]);
	}
	
	// resolve function by name
	else {
		
		// parse through table of function names
		
		for (DWORD i=0; i<pExportDirAddr->NumberOfNames; i++){
			char * sTmpFuncName = (char *) pBaseAddr + (DWORD_PTR) pFuncNameTbl[i];
			
			if(strcmp(sProcName, sTmpFuncName) == 0){
				// found, get the function virtual address = RVA + BaseAddr
				pProcAddr = (FARPROC) (pBaseAddr + (DWORD_PTR) pEAT[pHintsTbl[i]]);
				break;
			}
		}
		
	}
	
	// check if found RVA is forwarded to external library.function
	
	
	if((char *) pProcAddr >= (char*) pExportDirAddr && 
		(char *) pProcAddr < (char * ) (pExportDirAddr + pExportDataDir->Size)){
			
		char * sFwdDLL = _strdup((char *) sProcAddr);	// get a copy of library.function string
		if (!sFwdDLL) return NULL;
		
		// get external function name
		
		char * sFwdFunction = strchr(sFwdDLL, '.'); // point to where the string terminates (library....)
		*sFwdFunction = 0; // set trailing null byte for external library name library\x0function
		sFwdFunction++; // shift a pointer to the begginig of function name
		
		// resolve LoadLibrary function pointer, keep it as a global variable
		
		if(pLoadLibraryA == NULL){
			
			pLoadLibraryA = (LoadLibrary_t) hlpGetProcAddress(hlpGetModuleHandle("KERNEL32.DLL"), "LoadLibraryA");
			if (pLoadLibraryA == NULL) return NULL;
		}
		
		
		// load the external library
		
		HMODULE hFwd = pLoadLibraryA(sFwdDLL);
		free(sFwdDLL);
		if(!hFwd) return NULL;
		
		// get the address of function the original call is forwarded to
		pProcAddr = hlpGetProcAddress(hFwd, sFwdFunction);
			
		}
	
	return (FARPROC) pProcAddr;
	
	
}
